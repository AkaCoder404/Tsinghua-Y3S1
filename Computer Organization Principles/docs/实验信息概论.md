# Notes for the 实验指导

1. 掌握RISC-V
	a. 熟悉RISC-V指令系统，汇编程序
	b. 熟悉RISC-V指令格式 (must look at RISC-V handbook)
	c. 监控程序， simplified operating system that can recieve and execute commands, used to check correctness of final project
2. 掌握组合逻辑，时序逻辑
	a. review 数字逻辑
3. 掌握串口和SRAM
	a. both will be explained in the 实验指导书

review Verilog and Vivado
实验5，6之前完成 chapter 1 to 3 of 中文手册 

main files
QEMU
supervisor-rv 监控程序的源代and compiling environment
thinpad_top, vivado's topological file
toolchain, cross complication tool
compile kernal and start complication

open 编译Kernal并启动模拟器.cmd
open 启动Term并连接模拟器.cmd
open 打开命令行.cmd

setup Vivado environment http://thinpad.dynv6.net/Xilinx_Vivado_2019.2_1106_2127.tar.gz

第三章，第四章, 第五章 skip, all in rv.zip

## 第六章 RISC-V 指令概况
> https://dzone.com/articles/introduction-to-the-risc-v-architecture
- RISC-V 体系结构 is blocked, RV321 MOST BASIC, 32 bit command, must be implemented by all RISC-V 处理器. 
- RV64I, expansion of 64 基础指令 instruction
- RV32G, 通常指令
- RV32M, multiplication 指令
- RV32F, single precision floating point
- RV32D, double precision floating point
- RV32IMFD, make corresponding block statement 扩展 to RV32I

has 6 格式
1. operations between 寄存器 are R
2. short immediate operations and load are I
3. store as S
4. conditional jump as B
5. long as U
6. non conditional jump as J
-  all read/write registers are in fixed locations, registers can be accessed before decoding
- are all sign extended, and is in the highest bit. 

### RV321 Integer Operations
### RV321 Registers
- also exists a program counter 寄存器 not a 通用寄存器, holds address of current pointer
- categorized by name, with meanings: parameters, return address, which is saved by user, etc...
> https://inst.eecs.berkeley.edu/~cs61c/resources/su18_lec/Lecture7.pdf
- register x? value located in ppt pg29
- to low level hardware, no differences except x0
### RV321 Load and Store
- lw (32 bits), sw, 1b, 1bu, 1h (16 bits), 1hu
- Transfer data between a register and a memory location. First op is register to be loaded or stored, second register is containing a memory address. A signed 12-bit immediate value is added to the address in the register to produce the final address. 
- The only addressing mode supported by load and store is sign-extended 12-bit immediate data to the base address register. - 
- RISC-V uses a little-endian structure.
### RV321 Conditional Flow Instructions (Conditional)
- beq, bge, bgeu, blt, bltu
-Since the length of the RISC-V instruction must be a multiple of two bytes, the addressing mode of the branch instruction is a 12-bit immediate value multiplied by 2, sign extension, and then added to the PC as the branch jump address.
### RV321 non-conditional jump
- jal saves the address of the next instruction PC+4 to the target register, usually the return address register ra. If x0 is used to replace ra, an unconditional jump can be realized because x0 cannot be changed.
- jalr can call a function whose address is dynamically calculated, or it can also implement a call return (ra as the source register and x0 as the target register).

### RV32I 杂项
System Instructions (8)
1. ecall: invoke a system call. Registers used for passing parameters into and returning from the call are defined by ABI, not processor hardware
2. Initiate a debugger breakpoint.
3. CSR: read and write system control and status registers. CSR manipulation read the current value of selected CSR into register, then update CSR by either writing a new value, clearing selected bits, or setting selected bits.

### 函数调用惯例

## 第七章 Risc-V 汇编语言程序的调试 (pg 36)
purpose of chapter is to use GDB and QEMU to debug RISC-V programs. 
1. use -s to start a built-in gdb server on QEMU command line. 
2. Let's take a look at the execution process of the program by compiling to 32-bit code (because the program does not require any operating system support, it will easily go wrong, so use remote gdb to execute a single instruction and observe the execution of the register.

Definition of ABI
> Whereas an API defines a source interface, an ABI defines the low-level binary interface between two or more pieces of software on a particular architecture. It defines how an application interacts with itself, how an application interacts with the kernel, and how an application interacts with libraries.

Steps


1. open up kernal
2. open up term
3. open up 命令执行.cmd
riscv64-unknown-elf-c++ -nostdlib -nostdinc -static -g -Ttext 0x80000000 C:\Users\ligeo\Desktop\rv\sum.s -o C:\Users\ligeo\Desktop\rv\sum.elf -march=rv32i -mabi=ilp32

riscv64-unknown-elf-objdump -d  C:\Users\ligeo\Desktop\rv\sum.elf

QEMU-system-riscv32 -m 2G -nographic -machine virt -kernel C:\Users\ligeo\Desktop\rv\sum.elf -s -S

4. open new 命令执行.cmd

riscv64-unknown-elf-gdb C:\Users\ligeo\Desktop\rv\sum.elf

target remote localhost:1234